/**
 * Akoya
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { isExpired, isValid } from './authentication';
import { OauthToken } from './models/oauthToken';
import { ClientInterface } from './clientInterface';
import { OauthAuthorizationApi } from './controllers/oauthAuthorizationApi';
import { AUTHORIZATION_HEADER, setHeader } from '@apimatic/http-headers';

export class AuthorizationCodeAuthManager {
  private _oauthClientId: string;
  private _oauthClientSecret: string;
  private _oauthRedirectUri: string;
  private _oauthToken?: OauthToken;
  private _oauthScopes?: OauthScope[];
  private _oauthClockSkew?: number;
  private _oAuthController: OauthAuthorizationApi;
  private _baseUri: string;

  constructor(
    {
      oauthClientId,
      oauthClientSecret,
      oauthRedirectUri,
      oauthToken,
      oauthScopes,
      oauthClockSkew,
    }: {
      oauthClientId: string;
      oauthClientSecret: string;
      oauthRedirectUri: string;
      oauthToken?: OauthToken;
      oauthScopes?: OauthScope[];
      oauthClockSkew?: number;
    },
    baseUri: string,
    client: ClientInterface
  ) {
    this._oauthClientId = oauthClientId;
    this._oauthClientSecret = oauthClientSecret;
    this._oauthRedirectUri = oauthRedirectUri;
    this._oauthToken = oauthToken;
    this._oauthScopes = oauthScopes;
    this._oauthClockSkew = oauthClockSkew;
    this._oAuthController = new OauthAuthorizationApi(client);
    this._baseUri = baseUri;
  }

  public buildAuthorizationUrl(
    state: string,
    connector: string,
    additionalParams?: Record<string, string>
  ): string {
    let query = this._baseUri + '/auth';
    const queryParams: Record<string, string | undefined> = {
      response_type: 'code',
      client_id: this._oauthClientId,
      redirect_uri: this._oauthRedirectUri,
      scope: ['openid', 'profile', 'offline_access'].join(' '),
      connector: connector,
      state: state,
      ...additionalParams,
    };
    const queryString: string[] = [];
    for (const key of Object.keys(queryParams)) {
      const value = queryParams[key];
      if (value !== undefined && value !== null) {
        queryString.push(
          `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
        );
      }
    }
    return (query +=
      (query.indexOf('?') === -1 ? '?' : '&') + queryString.join('&'));
  }

  public async updateToken(): Promise<OauthToken> {
    if (!this.isValid(this._oauthToken)) {
      throw new Error('Unable to refresh token');
    }
    if (!this.isExpired(this._oauthToken)) {
      return this._oauthToken;
    }
    this._oauthToken = await this.refreshToken();
    return this._oauthToken;
  }

  public isValid(oAuthToken: OauthToken | undefined): oAuthToken is OauthToken {
    return isValid(oAuthToken);
  }

  public isExpired(oAuthToken: OauthToken) {
    return isExpired(oAuthToken, this._oauthClockSkew);
  }

  public async fetchToken(
    authorizationCode: string,
    additionalParams?: Record<string, unknown>
  ): Promise<OauthToken> {
    const authorization = this.getClientBasicAuth(
      this._oauthClientId,
      this._oauthClientSecret
    );
    const { result } = await this._oAuthController.requestToken(
      authorization,
      authorizationCode,
      this._oauthRedirectUri,
      additionalParams
    );
    return this.setExpiry(result);
  }

  public async refreshToken(
    additionalParams?: Record<string, unknown>
  ): Promise<OauthToken> {
    if (typeof this._oauthToken?.refreshToken === 'undefined') {
      throw new Error();
    }
    const { result } = await this._oAuthController.refreshToken(
      this._oauthToken?.refreshToken,
      this._oauthClientId,
      this._oauthClientSecret,
      additionalParams
    );
    return this.setExpiry(result);
  }

  private getClientBasicAuth(clientId: string, clientSecret: string): string {
    return `Basic ${Buffer.from(clientId + ':' + clientSecret).toString(
      'base64'
    )}`;
  }

  private async setExpiry(token: OauthToken) {
    const newToken = token;
    if (newToken.expiresIn) {
      newToken.expiry =
        BigInt(Math.round(Date.now() / 1000)) + newToken.expiresIn;
    }
    return newToken;
  }

  public setOAuthHeader = (request: any, token?: OauthToken) => {
    if (!token || !token.idToken) {
      throw new Error('OAuth token or idToken is missing.');
    }
    setHeader(
      request.headers,
      AUTHORIZATION_HEADER,
      `Bearer ${token?.idToken}`
    );
  };

  public async revokeToken(
    additionalParams?: Record<string, unknown>
  ): Promise<void> {
    if (typeof this._oauthToken?.refreshToken === 'undefined') {
      throw new Error();
    }
    await this._oAuthController.revokeToken(
      this._oauthToken?.refreshToken,
      this._oauthClientId,
      this._oauthClientSecret,
      additionalParams
    );
  }
}
